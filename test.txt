it('LoadRegion(): on success should call feeApiservice.getRequest(url+regionid), call LoadRegionData, clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // arrange - all inside test
  (component as any).regionid = 'R001';
  (component as any).appConfigService = { getRegionByIdUrl: '/api/region/' } as any;

  const regionObj = { regionId: 'R001', regionDesc: 'Region A' };
  const getSpy = spyOn(component.feeApiservice, 'getRequest').and.returnValue(of(regionObj));
  const loadRegionDataSpy = spyOn(component as any, 'LoadRegionData').and.callThrough();
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  // pre-set loading true to assert it is cleared
  component['loading'] = true;

  // act
  (component as any).LoadRegion();
  tick();

  // assert
  expect(getSpy).toHaveBeenCalledWith('/api/region/R001');
  expect(loadRegionDataSpy).toHaveBeenCalledWith(regionObj);
  expect(component['loading']).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled(); // LOADINGACTION(false)
}));


it('LoadRegion(): when API errors -> displayServiceErrors, clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).regionid = 'R002';
  (component as any).appConfigService = { getRegionByIdUrl: '/api/region/' } as any;

  const serverErr = { error: { statusMessage: 'server failed' } };
  spyOn(component.feeApiservice, 'getRequest').and.returnValue(throwError(() => serverErr));
  const displaySpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  component['loading'] = true;

  // act
  (component as any).LoadRegion();
  tick();

  // assert
  expect(displaySpy).toHaveBeenCalledWith('server failed');
  expect(component['loading']).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));


it('LoadRegion(): missing appConfigService.getRegionByIdUrl should not build "undefined" url (catch earlier bug)', fakeAsync(() => {
  // arrange: appConfigService exists but getRegionByIdUrl is undefined -> previous bug produced "undefinedR001"
  (component as any).regionid = 'R003';
  (component as any).appConfigService = { /* getRegionByIdUrl missing on purpose */ } as any;

  // Spy getRequest so we can detect how it was called if invoked
  const getSpy = spyOn(component.feeApiservice, 'getRequest').and.returnValue(of({ regionId: 'R003' }));
  const displaySpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  component['loading'] = true;

  // act
  (component as any).LoadRegion();
  tick();

  // assert - if code attempted to call getRequest with undefined+regionid we'd see it called with 'undefinedR003'
  // We assert that either getRequest was not called or it was called with a proper string (not 'undefinedR003')
  if (getSpy.calls.any()) {
    const calledWith = getSpy.calls.mostRecent().args[0];
    expect(String(calledWith)).not.toContain('undefinedR003');
  } else {
    // safe path: if no request made because config missing, ensure user saw an error or loading cleared
    // At minimum, loading must be cleared and dispatch called.
    expect(component['loading']).toBeFalse();
    expect(dispatchSpy).toHaveBeenCalled();
  }

  // If app decided to display an error for missing config, don't fail the test â€” just ensure no crash
  // (optional) assert displayServiceErrors not throwing:
  expect(displaySpy).not.toBeUndefined();
}));