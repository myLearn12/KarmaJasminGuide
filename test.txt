it('LoadDefaultComboBox (robust): on complete should set combo data and deep-clone viewchild.options', fakeAsync(() => {
  // Arrange --------------------------------------------------------------
  // Provide many possible appConfig keys so the component reading
  // private appConfigService won't crash if property name differs.
  (component as any).appConfigService = {
    getAllCategoryUrl: '/api/categories',
    getAllCategoriesUrl: '/api/categories',            // alternate name
    getAllDivisionUrl: '/api/divisions',
    getAllDivisionsUrl: '/api/divisions'               // alternate name
  } as any;

  // Realistic backend responses
  const categories = [{ categoryId: 7, categoryDescription: 'Estate', categoryCode: '4' }];
  const divisions  = [{ divisionId: 20, divisionDesc: 'Division A', divisionCd: 'D1' }];

  // Spy getRequest - be tolerant: match by substring (case-insensitive)
  const calledUrls: string[] = [];
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: any) => {
    const s = String(url || '').toLowerCase();
    calledUrls.push(String(url));
    if (s.includes('category'))      return of(categories);
    if (s.includes('division'))      return of(divisions);
    // fallback: return harmless empty
    return of([]);
  });

  // Make LoadComboBoxData tolerant too: return mapping for any label variant
  const mappedCategories = [{ label: 'Estate', value: '7' }];
  const mappedDivisions  = [{ label: 'Division A', value: '20' }];
  spyOn(component['utils'], 'LoadComboBoxData').and.callFake((arr: any[], label: string) => {
    const lbl = (label || '').toLowerCase();
    if (lbl.includes('category')) return mappedCategories;
    if (lbl.includes('division')) return mappedDivisions;
    return [];
  });

  // Provide mocks for all possible ViewChild names the component might use
  (component as any)._categoryComboBox = { options: null };
  (component as any).categoryComboBox  = (component as any)._categoryComboBox;
  (component as any)._divisionComboBox = { options: null };
  (component as any).divisionComboBox  = (component as any)._divisionComboBox;

  // Pre-check: ensure things are not already set (helps debugging failures)
  expect(component.categoryComboBoxData).not.toEqual([{ options: mappedCategories }]);
  expect((component as any)._divisionComboBox.options).toBeNull();

  // Act ------------------------------------------------------------------
  // call method under test (it uses forkJoin(...).subscribe({... complete: ...}))
  (component as any).LoadDefaultComboBox();
  tick(); // flush forkJoin / subscribe next + complete

  // Debugging aid: if the test still fails, we want to see what URLs were actually called
  if (!calledUrls.some(u => String(u).toLowerCase().includes('category'))
      || !calledUrls.some(u => String(u).toLowerCase().includes('division'))) {
    fail('LoadDefaultComboBox test URL mismatch â€” calledUrls: ' + JSON.stringify(calledUrls, null, 2));
    return;
  }

  // Assert ---------------------------------------------------------------
  // Combo data arrays should contain the mapped options we returned from utils.LoadComboBoxData
  expect(component.categoryComboBoxData).toEqual([{ options: mappedCategories }]);
  expect(component.divisionComboBoxData).toEqual([{ options: mappedDivisions }]);

  // ViewChild .options should be deep clones of the raw response arrays
  expect((component as any)._categoryComboBox.options).toEqual(JSON.parse(JSON.stringify(categories)));
  expect((component as any)._divisionComboBox.options).toEqual(JSON.parse(JSON.stringify(divisions)));
}));