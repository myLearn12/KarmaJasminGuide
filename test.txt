it('processRecord(): on success builds payload skipping empty rows, posts to restoreAccountUrl + "1", calls LoadTableRows, clears loading and dispatches LOADINGACTION(false)', fakeAsync(() => {
  // arrange - fully self-contained
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).region = { regionId: 55 };
  (component as any).selectedMonthEndDate = '2025-01-31';
  (component as any).currentDateTime = '2025-01-31T10:00:00Z';
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;
  (component as any)._actionModal = { show: jasmine.createSpy('show') };
  (component as any).LoadTableRows = jasmine.createSpy('LoadTableRows');
  (component as any).clearSelection = jasmine.createSpy('clearSelection');

  (component as any).worksheet = {
    Sheet1: [
      { AccountNumber: 'ACC1' },
      { AccountNumber: '' },      // should be skipped
      { AccountNumber: 'ACC2' }
    ]
  };

  spyOn((component as any).utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-01-31T00:00:00Z');
  spyOn((component as any).utils, 'getCurrentUser').and.returnValue('tester');
  spyOn((component as any).utils, 'ToEstDate').and.returnValue('2025-01-31');

  const serverResp = [{ hasError: false }, { hasError: false }];
  const postSpy = spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(serverResp));
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  // pre-set loading true
  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(postSpy).toHaveBeenCalled();
  const calledUrl = postSpy.calls.mostRecent().args[0];
  expect(String(calledUrl)).toContain('/api/restore/');
  expect(String(calledUrl)).toContain('1'); // screenshot shows + "1"
  const payload = postSpy.calls.mostRecent().args[1];
  expect(Array.isArray(payload)).toBeTrue();
  expect(payload.length).toBe(2);
  expect(payload[0].acctnum).toBe('ACC1');
  expect(payload[1].acctnum).toBe('ACC2');

  expect((component as any).LoadTableRows).toHaveBeenCalledWith(serverResp);
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
  expect((component as any).clearSelection).toHaveBeenCalled();
}));

it('processRecord(): when response contains at least one hasError true -> sets totalErrorRecordCount > 0, isData true, shows modal', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any)._actionModal = { show: jasmine.createSpy('show') };
  (component as any).LoadTableRows = jasmine.createSpy('LoadTableRows');
  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'X' }] };

  spyOn((component as any).utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-01-31T00:00:00Z');
  spyOn((component as any).utils, 'getCurrentUser').and.returnValue('u');
  spyOn((component as any).utils, 'ToEstDate').and.returnValue('2025-01-31');

  const resp = [{ hasError: true }, { hasError: false }];
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(resp));
  spyOn((component as any).store, 'dispatch');

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect((component as any).totalErrorRecordCount).toBeGreaterThan(0);
  expect((component as any).isData).toBeTrue();
  expect((component as any)._actionModal.show).toHaveBeenCalled();
}));

it('processRecord(): when response all hasError false -> totalErrorRecordCount 0, isData false, modal still shown', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any)._actionModal = { show: jasmine.createSpy('show') };
  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'Y' }] };

  spyOn((component as any).utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-01-31T00:00:00Z');
  spyOn((component as any).utils, 'getCurrentUser').and.returnValue('u');
  spyOn((component as any).utils, 'ToEstDate').and.returnValue('2025-01-31');

  const resp = [{ hasError: false }];
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(resp));
  spyOn((component as any).store, 'dispatch');

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect((component as any).totalErrorRecordCount).toBe(0);
  expect((component as any).isData).toBeFalse();
  expect((component as any)._actionModal.show).toHaveBeenCalled();
}));

it('processRecord(): when feeApiservice.postRequest errors -> calls displayServiceErrors with statusMessage, clears loading and dispatches LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'Z' }] };

  const serverErr = { error: { statusMessage: 'server failed' } };
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(throwError(() => serverErr));
  const dispSpy = spyOn(component as any, 'displayServiceErrors').and.callFake(() => {});
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(dispSpy).toHaveBeenCalledWith('server failed');
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));

it('processRecord(): when worksheet contains only empty/null account values -> should not call postRequest, should clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).worksheet = { Sheet1: [{ AccountNumber: '' }, { AccountNumber: null }] };

  const postSpy = spyOn((component as any).feeApiservice, 'postRequest');
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(postSpy).not.toHaveBeenCalled();
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));

it('processRecord(): does not crash if appConfigService.restoreAccountUrl missing and handles gracefully (no "undefined" URL)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  // intentionally missing restoreAccountUrl
  (component as any).appConfigService = {} as any;
  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'P1' }] };

  const postSpy = spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of([]));
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  // act
  (component as any).processRecord();
  tick();

  // assert - either no call or URL should not contain 'undefined' concatenation
  if (postSpy.calls.any()) {
    const calledUrl = String(postSpy.calls.mostRecent().args[0]);
    expect(calledUrl).not.toContain('undefined');
  } else {
    // safe fallback: at least loading must be cleared and dispatch invoked
    expect((component as any).loading).toBeFalse();
    expect(dispatchSpy).toHaveBeenCalled();
  }
}));