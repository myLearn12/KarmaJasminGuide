import * as rx from 'rxjs';
import { of, throwError } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('InitialDataLoad: success → showReportScreen=true → loads tab data and shows report', fakeAsync(() => {
  const mockDate = '2025-08-01';
  const mockPostingEndDt = '2025-08-15';
  const innerTabData = [{ id: 1 }, { id: 2 }];

  // Dates
  spyOn(TestBed.inject(CommonFunctionsService), 'ToDate').and.returnValue(new Date(mockDate));

  // Report service
  const reportSvc = TestBed.inject(DetailauditreportService);
  const setPostingSpy = spyOn(reportSvc, 'setPostingEndDate');
  const showScreenSpy = spyOn(reportSvc, 'showReportScreen').and.returnValue(true);
  const setTabSpy = spyOn(reportSvc, 'setDetailAuditReportTab');

  // Store
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // IMPORTANT: stub rx.forkJoin to emit shapes the component actually READS
  // Outer emits { cashpostDt: [...] }
  // Inner emits { changeReportTabData: [...] }
  const forkSpy = spyOn(rx, 'forkJoin').and.returnValues(
    of({ cashpostDt: [{ postingEndDt: mockPostingEndDt }] }),
    of({ changeReportTabData: innerTabData })
  );

  // feeApiService present but not used because forkJoin is stubbed; keep it for call count if needed
  const feeApiSpy = jasmine.createSpyObj('feeApiservice', ['getRequest']);
  component.feeApiservice = feeApiSpy as any;

  // Act
  component.InitialDataLoad();
  tick();

  // Assert
  expect(component.postingEndDt).toBe(mockPostingEndDt);
  expect(setPostingSpy).toHaveBeenCalledWith(mockPostingEndDt);
  expect(showScreenSpy).toHaveBeenCalledWith(mockPostingEndDt);

  expect(setTabSpy).toHaveBeenCalledWith(innerTabData);
  expect(component.showReportScreens).toBeTrue();

  // loading end
  expect(dispatchSpy).toHaveBeenCalled(); // LOADINGACTION(false) at the end
}));


import * as rx from 'rxjs';
import { of } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('InitialDataLoad: success → showReportScreen=false → sets actionMessage and no inner call', fakeAsync(() => {
  const mockDate = '2025-08-01';
  const mockPostingEndDt = '2025-08-15';

  spyOn(TestBed.inject(CommonFunctionsService), 'ToDate').and.returnValue(new Date(mockDate));
  spyOn(TestBed.inject(CommonFunctionsService), 'getDisplayDate').and.returnValue('15-Aug-2025');

  const reportSvc = TestBed.inject(DetailauditreportService);
  const setPostingSpy = spyOn(reportSvc, 'setPostingEndDate');
  const showScreenSpy = spyOn(reportSvc, 'showReportScreen').and.returnValue(false);

  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Only outer forkJoin fires; emit the shape the code reads
  spyOn(rx, 'forkJoin').and.returnValues(
    of({ cashpostDt: [{ postingEndDt: mockPostingEndDt }] })
  );

  const feeApiSpy = jasmine.createSpyObj('feeApiservice', ['getRequest']);
  component.feeApiservice = feeApiSpy as any;

  component.InitialDataLoad();
  tick();

  expect(component.postingEndDt).toBe(mockPostingEndDt);
  expect(setPostingSpy).toHaveBeenCalledWith(mockPostingEndDt);
  expect(showScreenSpy).toHaveBeenCalledWith(mockPostingEndDt);

  // Inner call should not happen → forkJoin called only once
  // (we stubbed it to returnValues with single emission)
  expect(component.showReportScreens).toBeFalse();
  expect(component.actionMessage).toContain('Change Report for');
  expect(dispatchSpy).toHaveBeenCalled(); // LOADINGACTION(false)
}));

import * as rx from 'rxjs';
import { throwError } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('InitialDataLoad: outer API error → display error and clear loading', fakeAsync(() => {
  const mockDate = '2025-08-01';
  spyOn(TestBed.inject(CommonFunctionsService), 'ToDate').and.returnValue(new Date(mockDate));

  const errSpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  spyOn(rx, 'forkJoin').and.returnValue(
    throwError(() => ({ error: { statusMessage: 'Outer fail' } }))
  );

  component.InitialDataLoad();
  tick();

  expect(errSpy).toHaveBeenCalledWith('Outer fail');
  expect(dispatchSpy).toHaveBeenCalled(); // LOADINGACTION(false)
  expect(component.loading).toBeFalse();
}));

import * as rx from 'rxjs';
import { of, throwError } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('InitialDataLoad: inner API error after showReportScreen=true → display error & clear loading', fakeAsync(() => {
  const mockDate = '2025-08-01';
  const mockPostingEndDt = '2025-08-15';

  spyOn(TestBed.inject(CommonFunctionsService), 'ToDate').and.returnValue(new Date(mockDate));

  const reportSvc = TestBed.inject(DetailauditreportService);
  spyOn(reportSvc, 'showReportScreen').and.returnValue(true);
  const setPostingSpy = spyOn(reportSvc, 'setPostingEndDate');

  const errSpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Outer emits posting date; Inner throws error with the exact shape the code reads
  spyOn(rx, 'forkJoin').and.returnValues(
    of({ cashpostDt: [{ postingEndDt: mockPostingEndDt }] }),
    throwError(() => ({ error: { statusMessage: 'Inner fail' } }))
  );

  const feeApiSpy = jasmine.createSpyObj('feeApiservice', ['getRequest']);
  component.feeApiservice = feeApiSpy as any;

  component.InitialDataLoad();
  tick();

  expect(setPostingSpy).toHaveBeenCalledWith(mockPostingEndDt);
  expect(errSpy).toHaveBeenCalledWith('Inner fail');
  expect(dispatchSpy).toHaveBeenCalled(); // LOADINGACTION(false)
  expect(component.loading).toBeFalse();
}));
