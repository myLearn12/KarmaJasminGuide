// Fixed, self-contained tests for processRecord() â€” no describe/beforeEach, all setup inside each it()

it('processRecord(): on success builds payload skipping empty rows, posts to restoreAccountUrl + "1", calls LoadTableRows, clears loading and dispatches LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber'; // use same key as rows
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;
  (component as any).region = { regionId: 55 };
  (component as any).selectedMonthEndDate = '2025-01-31';
  (component as any).currentDateTime = '2025-01-31T10:00:00Z';

  (component as any)._actionModal = { show: jasmine.createSpy('show') };
  (component as any).LoadTableRows = jasmine.createSpy('LoadTableRows');
  (component as any).clearSelection = jasmine.createSpy('clearSelection');

  (component as any).utils = {
    getFormatedDateAndTimeEST: () => '2025-01-31T00:00:00Z',
    getCurrentUser: () => 'tester',
    ToEstDate: () => '2025-01-31'
  };

  (component as any).worksheet = {
    Sheet1: [
      { AccountNumber: 'ACC1' },
      { AccountNumber: '' },   // should be skipped
      { AccountNumber: 'ACC2' }
    ]
  };

  const serverResp = [{ hasError: false }, { hasError: false }];
  const postSpy = spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(serverResp));
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(postSpy).toHaveBeenCalled();
  const calledUrl = String(postSpy.calls.mostRecent().args[0]);
  expect(calledUrl).toContain('/api/restore/');
  expect(calledUrl).toContain('1'); // screenshot shows + "1"

  const payload = postSpy.calls.mostRecent().args[1];
  expect(Array.isArray(payload)).toBeTrue();
  expect(payload.length).toBe(2);
  expect(payload[0].acctnum).toBe('ACC1');
  expect(payload[1].acctnum).toBe('ACC2');

  expect((component as any).LoadTableRows).toHaveBeenCalledWith(serverResp);
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
  expect((component as any).clearSelection).toHaveBeenCalled();
}));

it('processRecord(): when response contains at least one hasError true -> sets totalErrorRecordCount > 0, isData true and shows modal', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;
  (component as any)._actionModal = { show: jasmine.createSpy('show') };
  (component as any).LoadTableRows = jasmine.createSpy('LoadTableRows');

  (component as any).utils = {
    getFormatedDateAndTimeEST: () => '2025-01-31T00:00:00Z',
    getCurrentUser: () => 'u',
    ToEstDate: () => '2025-01-31'
  };

  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'X' }] };

  const resp = [{ hasError: true }, { hasError: false }];
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(resp));
  spyOn((component as any).store, 'dispatch');

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect((component as any).totalErrorRecordCount).toBeGreaterThan(0);
  expect((component as any).isData).toBeTrue();
  expect((component as any)._actionModal.show).toHaveBeenCalled();
}));

it('processRecord(): when response all hasError false -> totalErrorRecordCount 0, isData false, modal shown', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;
  (component as any)._actionModal = { show: jasmine.createSpy('show') };

  (component as any).utils = {
    getFormatedDateAndTimeEST: () => '2025-01-31T00:00:00Z',
    getCurrentUser: () => 'u',
    ToEstDate: () => '2025-01-31'
  };

  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'Y' }] };

  const resp = [{ hasError: false }];
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of(resp));
  spyOn((component as any).store, 'dispatch');

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect((component as any).totalErrorRecordCount).toBe(0);
  expect((component as any).isData).toBeFalse();
  expect((component as any)._actionModal.show).toHaveBeenCalled();
}));

it('processRecord(): on feeApiservice.postRequest error -> calls displayServiceErrors, clears loading and dispatches LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;

  (component as any).utils = {
    getFormatedDateAndTimeEST: () => '2025-01-31T00:00:00Z',
    getCurrentUser: () => 'u',
    ToEstDate: () => '2025-01-31'
  };

  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'Z' }] };

  const serverErr = { error: { statusMessage: 'server failed' } };
  spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(throwError(() => serverErr));
  const dispSpy = spyOn(component as any, 'displayServiceErrors').and.callThrough();
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(dispSpy).toHaveBeenCalledWith('server failed');
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));

it('processRecord(): when worksheet has only empty/null account values -> should not call postRequest, should clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  (component as any).appConfigService = { restoreAccountUrl: '/api/restore/' } as any;

  (component as any).worksheet = { Sheet1: [{ AccountNumber: '' }, { AccountNumber: null }] };

  const postSpy = spyOn((component as any).feeApiservice, 'postRequest');
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert
  expect(postSpy).not.toHaveBeenCalled();
  expect((component as any).loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));

it('processRecord(): missing appConfigService.restoreAccountUrl should not crash and should not produce "undefined" URL', fakeAsync(() => {
  // arrange
  (component as any).sheetName = 'Sheet1';
  (component as any).accoutColumnHeader = 'AccountNumber';
  // intentionally missing restoreAccountUrl
  (component as any).appConfigService = {} as any;
  (component as any).worksheet = { Sheet1: [{ AccountNumber: 'P1' }] };

  const postSpy = spyOn((component as any).feeApiservice, 'postRequest').and.returnValue(of([]));
  const dispatchSpy = spyOn((component as any).store, 'dispatch');

  (component as any).loading = true;

  // act
  (component as any).processRecord();
  tick();

  // assert: either no call or URL must not contain 'undefined'
  if (postSpy.calls.any()) {
    const calledUrl = String(postSpy.calls.mostRecent().args[0]);
    expect(calledUrl).not.toContain('undefined');
  } else {
    expect((component as any).loading).toBeFalse();
    expect(dispatchSpy).toHaveBeenCalled();
  }
}));