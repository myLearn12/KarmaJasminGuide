it('onAcceptButtonClick(ActionType.update): next() should regenerate table & show success; complete() should build updateModel and call auditLogService.writeAuditLog', fakeAsync(() => {
  // --- Arrange ---
  // Make validateFormControls allow execution
  spyOn(component as any, 'validateFormControls').and.returnValue(false);

  // Provide the model that will be updated
  component.selectedaltdivabacostcntrmap = {
    altDivIdCostCntrMapId: 999,
    startDt: '2025-01-01T00:00:00.000Z',
    endDt: '9999-12-31T00:00:00.000Z'
  } as any;

  // Current (mutated) object that should be restored/used in audit call
  component.altdivabacostcntrmap = {
    altDivIdCostCntrMapId: 999,
    altDivId: 20,
    abaNbr: 'ABA-NEW',
    costCenterNbr: '200',
    startDt: null,
    endDt: null
  } as any;

  // Make sure division/costCenter arrays exist if getUpdatedModel uses them
  component.divisions = [{ divisionId: 20, divisionDesc: 'Div A', divisionCd: 'D1' }] as any;
  component.costCenters = [{ costCenterId: 1, costCenterNbr: '200', costCenterDesc: 'Cost B' }] as any;

  // Provide any viewchild values used by getUpdatedModel (if any)
  (component as any)._divisionComboBox = { value: '20' };
  (component as any)._costCenterComboBox = { value: '200' };

  // Spy on methods called in subscription next/complete
  const genSpy = spyOn(component as any, 'GenerateTableRows').and.callFake(() => {});
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue').and.callFake(() => {});

  // Provide auditLogService and spy writeAuditLog
  (component as any).auditLogService = {
    writeAuditLog: (_a?: any, _b?: any, _c?: any, _d?: any, _e?: any, _f?: any) => {}
  };
  const auditSpy = spyOn((component as any).auditLogService, 'writeAuditLog').and.callThrough();

  // Ensure getUpdatedModel returns an object the component will modify
  spyOn(component as any, 'getUpdatedModel').and.returnValue({ startDt: null, endDt: null });

  // Stub feeApiservice.putRequest to return a successful observable so next() and complete() run
  const putSpy = spyOn(component.feeApiservice, 'putRequest').and.returnValue(of({}));

  // Final cleanup spies
  const clearSpy = spyOn(component as any, 'clearSelection').and.callFake(() => {});
  (component as any)._actionModal = { hide: () => {} };
  const modalHideSpy = spyOn((component as any)._actionModal, 'hide').and.callThrough();

  // Make sure an updateSuccessMessage exists
  (component as any).updateSuccessMessage = 'Updated successfully';

  // --- Act ---
  component.onAcceptButtonClick(ActionType.update);
  tick(); // process the putRequest observable, next + complete

  // --- Assert ---
  expect(putSpy).toHaveBeenCalled();                       // HTTP call
  expect(genSpy).toHaveBeenCalled();                       // next() triggers GenerateTableRows
  expect(setMsgSpy).toHaveBeenCalledWith(jasmine.anything(), component.updateSuccessMessage);

  // complete() should call getUpdatedModel and then auditLogService.writeAuditLog
  expect((component as any).getUpdatedModel).toHaveBeenCalled();
  expect(auditSpy).toHaveBeenCalled();

  const args = auditSpy.calls.mostRecent().args;
  expect(args[0]).toBe('altDivIdCostCntrMapId');           // first param key
  expect(args[1]).toBe(component.altdivabacostcntrmap.altDivIdCostCntrMapId.toString()); // id as string
  expect(typeof args[2]).toBe('object');                   // selected (old) object passed
  expect(typeof args[3]).toBe('object');                   // updateModel passed
  expect(args[5]).toBeDefined();                           // page title exists

  // cleanup still called
  expect(clearSpy).toHaveBeenCalled();
  expect(modalHideSpy).toHaveBeenCalled();
}));
