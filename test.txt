it('LoadDefaultComboBox: on error should call displayServiceErrors, stop loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // Arrange: set private appConfig URLs
  (component as any).appConfigService = {
    getAllRevShareTypeCdUrl: '/api/revsharetypes',
    getAllDivisionUrl: '/api/divisions'
  } as any;

  // Make feeApiservice.getRequest throw for the forkJoin
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: string) =>
    throwError(() => ({ error: { statusMessage: 'LoadDefault failed' } }))
  );

  // Make sure viewchild mocks exist (prevents unrelated null errors)
  (component as any).revenueShareComboBox = { options: null };
  (component as any)._divisionComboBox = { options: null };

  const displaySpy = spyOn(component as any, 'displayServiceErrors').and.callThrough();
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // initial loading true to simulate real flow
  component.loading = true;

  // Act
  component.LoadDefaultComboBox();
  tick();

  // Assert
  expect(displaySpy).toHaveBeenCalledWith('LoadDefault failed');
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
  // ensure LOADINGACTION was called with false payload (if your LOADINGACTION stores payload)
  // If LOADINGACTION is a simple class with constructor(flag:boolean) you can check:
  const calledArgs = dispatchSpy.calls.allArgs().flat();
  expect(calledArgs.some(a => a instanceof LOADINGACTION && (a as any).payload === false || (a as any).payload === undefined)).toBeTrue();
}));