import { of, throwError } from 'rxjs';
import { fakeAsync, tick } from '@angular/core/testing';

it('ngOnInit(): ERROR branch - should call displayServiceErrors, call LoadDefaultComboBox on 404, clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // Arrange - make feeApiservice.getRequest return an observable that errors
  const err = { error: { statusMessage: 'server failed', statusCode: '404' } };

  spyOn(component.feeApiservice, 'getRequest').and.returnValue(throwError(() => err));

  // Spy displayServiceErrors and LoadDefaultComboBox and store.dispatch
  const dispSpy = spyOn(component as any, 'displayServiceErrors').and.callThrough();
  const loadDefaultSpy = spyOn(component as any, 'LoadDefaultComboBox').and.callFake(() => {});
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Pre-set loading true to verify it gets cleared
  component.loading = true;

  // Act
  component.ngOnInit();
  tick(); // flush the subscription error

  // Assert
  expect(dispSpy).toHaveBeenCalledWith('server failed');
  expect(loadDefaultSpy).toHaveBeenCalled(); // because statusCode === "404"
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));


it('ngOnInit(): COMPLETE branch - should set combo data, deep-clone viewchild.options, clear loading and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // Arrange - realistic results that forkJoin would return
  const catMnrmaps = [{ some: 'row' }];
  const categories = [{ categoryId: 7, categoryDescription: 'Estate', categoryCode: '4' }];
  const accountMinors = [{ acctMnrTypeCode: 'AM1', acctMnrTypeDesc: 'Minor A' }];

  // Spy getRequest to return corresponding arrays depending on URL or call order
  // (robust: use substring matching on URL if you have appConfigService; else return in order)
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url?: string) => {
    const u = String(url || '').toLowerCase();
    if (u.includes('mnr') || u.includes('mnr')) return of(catMnrmaps);
    if (u.includes('category')) return of(categories);
    if (u.includes('acctmnr') || u.includes('acctmnrtype')) return of(accountMinors);
    // fallback so forkJoin still receives values if URL matching fails
    return of([]);
  });

  // utils helpers
  const mappedCategories = [{ label: 'Estate', value: '7' }];
  const mappedMinors = [{ label: 'Minor A', value: 'AM1' }];
  spyOn(component['utils'], 'LoadComboBoxData').and.callFake((arr: any[], label: string, _c: string, id: string) => {
    if (label === 'categoryDescription') return mappedCategories;
    if (label === 'acctMnrTypeDesc') return mappedMinors;
    return [];
  });

  // Provide ViewChild mocks so assignments to .options don't throw
  (component as any)._categoryComboBox = { options: null };
  (component as any)._minorComboBox = { options: null };

  // Prevent LoadTableRows side effects and spy it (we just want it called with the data)
  const loadRowsSpy = spyOn(component as any, 'LoadTableRows').and.callFake(() => {});

  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Act
  component.ngOnInit();
  tick(); // flush forkJoin next + complete

  // Assert: LoadTableRows was called with mapped first arg (catMnrmaps) and accountMinors available
  expect(loadRowsSpy).toHaveBeenCalledWith(catMnrmaps, accountMinors);

  // Assert: combo data arrays built using utils.LoadComboBoxData
  expect(component.categoryComboBoxData).toEqual([{ options: mappedCategories }]);
  expect(component.acctMinorComboBoxData).toEqual([{ options: mappedMinors }]);

  // Assert: viewchild options deep-cloned
  expect((component as any)._categoryComboBox.options).toEqual(JSON.parse(JSON.stringify(categories)));
  expect((component as any)._minorComboBox.options).toEqual(JSON.parse(JSON.stringify(accountMinors)));

  // loading turned off and LOADINGACTION(false) dispatched
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));
