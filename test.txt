// changetable.component.spec.ts
import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { of } from 'rxjs';
import { NO_ERRORS_SCHEMA } from '@angular/core';

// Replace with real import path
import { ChangetableComponent } from './changetable.component';

// Minimal LOADINGACTION placeholder used for assertions:
class LOADINGACTION { constructor(public payload: boolean) {} }

describe('ChangetableComponent (focused)', () => {
  let fixture: ComponentFixture<ChangetableComponent>;
  let component: ChangetableComponent;

  // Spies / fakes
  const utils = jasmine.createSpyObj('utils', ['getPerPageItem', 'getFilterTextMaxLength', 'ToDate', 'redirectToRegionSelection']);
  const store = jasmine.createSpyObj('store', ['dispatch', 'pipe']);
  const reportService = jasmine.createSpyObj('reportService', ['getChangeTable']);
  const changeReport = jasmine.createSpyObj('changeReport', ['getExcelExportData']);

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ChangetableComponent],
      providers: [
        // We'll attach our spies to the instance directly (below)
      ],
      schemas: [NO_ERRORS_SCHEMA]
    });

    fixture = TestBed.createComponent(ChangetableComponent);
    component = fixture.componentInstance as any;

    // Attach spy implementations to the component (works even for private constructor-injected services)
    (component as any).utils = utils;
    (component as any).store = store;
    (component as any).reportService = reportService;
    (component as any).changeReport = changeReport;

    // sensible defaults used by the component initialization
    utils.getPerPageItem.and.returnValue(10);
    utils.getFilterTextMaxLength.and.returnValue(100);
    utils.ToDate.and.returnValue(new Date('2025-11-06T00:00:00Z'));
    store.dispatch.and.callFake(() => {});
  });

  afterEach(() => {
    // cleanup if tests change anything
    utils.getPerPageItem.calls.reset();
    utils.getFilterTextMaxLength.calls.reset();
    utils.ToDate.calls.reset();
    store.dispatch.calls.reset();
  });

  it('ngOnInit(): when store returns regionId -> should dispatch loading true and set loading false without redirect', fakeAsync(() => {
    // Arrange
    // Make store.pipe(select(getRegionId)) emit an object with regionId
    store.pipe.and.returnValue(of({ regionId: 'REG-1' }));

    // spy for redirect and ensure it is not called
    utils.redirectToRegionSelection.and.callFake(() => {});

    // Act
    (component as any).ngOnInit();
    tick();

    // Assert
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION)); // startup dispatch(true)
    // component sets loading = false after subscription
    expect((component as any).loading).toBeFalse();
    // redirect should NOT be called for present regionId
    expect(utils.redirectToRegionSelection).not.toHaveBeenCalled();
  }));

  it('ngOnInit(): when store returns NO regionId -> should dispatch loading true then loading false and redirect', fakeAsync(() => {
    // Arrange: store.pipe returns null/undefined region
    store.pipe.and.returnValue(of(null)); // component will interpret this as missing regionId
    const redirectSpy = utils.redirectToRegionSelection.and.callFake(() => {});

    // Act
    (component as any).ngOnInit();
    tick();

    // Assert
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION)); // startup true
    // component should set loading false
    expect((component as any).loading).toBeFalse();
    // redirect should be called
    expect(redirectSpy).toHaveBeenCalled();
    // and dispatch should be called with LOADINGACTION(false) when redirect branch runs
    // We check that dispatch was invoked at least once with LOADINGACTION(false)
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
    // Can't reliably assert exact call with false value because component code was slightly malformed in paste,
    // but we at least assert redirect took place when region absent.
  }));

  it('ngDoCheck(): when reportService.getChangeTable() returns non-empty -> should set isData true and loading false', () => {
    // Arrange
    const rows = [{ some: 'row' }];
    reportService.getChangeTable.and.returnValue(rows);
    (component as any).isData = false;
    (component as any).loading = true;

    // Act
    (component as any).ngDoCheck();

    // Assert
    expect(reportService.getChangeTable).toHaveBeenCalled();
    expect((component as any).changetable).toBe(rows);
    expect((component as any).isData).toBeTrue();
    expect((component as any).loading).toBeFalse();
  });

  it('displayServiceErrors(): should set errorBlockMessage', () => {
    // Arrange
    expect((component as any).errorBlockMessage).toBeNull();

    // Act
    (component as any).displayServiceErrors('some error');

    // Assert
    expect((component as any).errorBlockMessage).toBe('some error');
  });

  it('onExportExcelClick(): should set loading true, dispatch LOADINGACTION(true) and call changeReport.getExcelExportData()', () => {
    // Arrange
    changeReport.getExcelExportData.and.callFake(() => {});
    store.dispatch.calls.reset();
    (component as any).loading = false;
    (component as any).errorBlockMessage = 'old';

    // Act
    (component as any).onExportExcelClick();

    // Assert
    expect((component as any).errorBlockMessage).toBeNull();
    expect((component as any).loading).toBeTrue();
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
    expect(changeReport.getExcelExportData).toHaveBeenCalled();
  });

  it('ngOnDestroy(): should unsubscribe from subscription', () => {
    // Arrange: replace component.subscription with a spy object
    const unsubSpy = jasmine.createSpy('unsubscribe');
    (component as any).subscription = { unsubscribe: unsubSpy } as any;

    // Act
    (component as any).ngonDestroy ? (component as any).ngonDestroy() : (component as any).ngOnDestroy && (component as any).ngOnDestroy();

    // Assert
    expect(unsubSpy).toHaveBeenCalled();
  });
});