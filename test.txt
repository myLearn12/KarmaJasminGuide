it('onSearchButtonClick: rbnTax true -> loads catGlmaps (id "1") and sets category combo', fakeAsync(() => {
  // Arrange
  (component as any).rbnTax = { value: true };
  (component as any).rbnNonTax = { value: false };

  (component as any).appConfigService = {
    getGetCatGlAcctMappingByIdUrl: '/api/catglmaps/' // component will append '1'
  } as any;

  const catGlmaps = [{ acct: 'A1' }];

  // spy getRequest: only the catGlmaps request is expected in this branch
  const calledUrls: string[] = [];
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: string) => {
    calledUrls.push(String(url));
    if (String(url).includes('/catglmaps/') && String(url).endsWith('1')) {
      return of(catGlmaps);
    }
    // if any unexpected call happens return empty array
    return of([]);
  });

  // Ensure LoadTableRows won't throw
  const loadSpy = spyOn(component as any, 'LoadTableRows').and.stub();
  spyOn(component as any, 'displayServiceErrors').and.stub();

  // ViewChild mock not required here because category combo isn't set in this branch
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Act
  component.onSearchButtonClick();
  tick();

  // Assert: one request was made and it was for id '1'
  expect(calledUrls.some(u => /catglmaps\/1$/.test(u))).toBeTrue();
  expect(loadSpy).toHaveBeenCalledWith(catGlmaps);

  // Do NOT assert dispatch in error path — this branch may or may not dispatch; but component usually clears loading somewhere
  // If your component sets loading=false here, assert it
  expect(component.loading).toBeFalse();
}));

it('onSearchButtonClick: rbnNonTax true -> loads catGlmaps (id "2") and sets table rows', fakeAsync(() => {
  (component as any).rbnTax = { value: false };
  (component as any).rbnNonTax = { value: true };

  (component as any).appConfigService = {
    getGetCatGlAcctMappingByIdUrl: '/api/catglmaps/'
  } as any;

  const catGlmaps = [{ acct: 'B1' }];
  const calledUrls: string[] = [];
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: string) => {
    calledUrls.push(String(url));
    if (String(url).includes('/catglmaps/') && String(url).endsWith('2')) {
      return of(catGlmaps);
    }
    return of([]);
  });

  const loadSpy = spyOn(component as any, 'LoadTableRows').and.stub();
  spyOn(component as any, 'displayServiceErrors').and.stub();
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  component.onSearchButtonClick();
  tick();

  expect(calledUrls.some(u => /catglmaps\/2$/.test(u))).toBeTrue();
  expect(loadSpy).toHaveBeenCalledWith(catGlmaps);
  expect(component.loading).toBeFalse();
}));

it('onSearchButtonClick: when catGlmaps request errors -> calls displayServiceErrors and clears catGlmaps', fakeAsync(() => {
  (component as any).rbnTax = { value: true };
  (component as any).rbnNonTax = { value: false };

  (component as any).appConfigService = {
    getGetCatGlAcctMappingByIdUrl: '/api/catglmaps/'
  } as any;

  const calledUrls: string[] = [];
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: string) => {
    calledUrls.push(String(url));
    if (String(url).includes('/catglmaps/') && String(url).endsWith('1')) {
      return throwError(() => ({ error: { statusMessage: 'boom' } }));
    }
    return of([]);
  });

  const displaySpy = spyOn(component as any, 'displayServiceErrors').and.stub();
  const loadSpy = spyOn(component as any, 'LoadTableRows').and.stub();
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Pre-populate catGlmaps so we can assert it got cleared on error (component sets catGlmaps = [])
  (component as any).catGlmaps = [{ acct: 'X' }];

  component.onSearchButtonClick();
  tick();

  expect(displaySpy).toHaveBeenCalledWith('boom');
  // LoadTableRows should NOT have been called with the success payload
  expect(loadSpy).not.toHaveBeenCalledWith(jasmine.arrayContaining([{ acct: 'A1' }]));
  // Expect component's catGlmaps cleared (if the code sets catGlmaps = [])
  expect((component as any).catGlmaps).toEqual([]);
  // Only assert dispatch if the component actually calls it in this error callback. Many versions don't — so don't assert here.
}));