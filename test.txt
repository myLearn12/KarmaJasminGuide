
it('LoadControlId(): when API errors should call displayServiceErrors and keep controlIdComboBoxData empty and dispatch LOADINGACTION(false)', fakeAsync(() => {
  // Arrange - make sure test is self-contained
  // Defensive: ensure appConfigService is present on the component
  if (!(component as any).appConfigService) {
    (component as any).appConfigService = { getAllControlIdurl: '/api/controlIds' } as any;
  } else if (!(component as any).appConfigService.getAllControlIdurl) {
    (component as any).appConfigService.getAllControlIdurl = '/api/controlIds';
  }

  // Spy getRequest to return an error observable
  const serverMessage = 'Server failure for control ids';
  const getSpy = spyOn(component.feeApiservice, 'getRequest').and.returnValue(
    throwError(() => ({ error: { statusMessage: serverMessage } }))
  );

  // Spy displayServiceErrors
  const displaySpy = spyOn(component as any, 'displayServiceErrors').and.callFake(() => {});

  // Spy store.dispatch (store is often private; use bracket access)
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callFake(() => {});

  // Optionally pre-fill controlIdComboBoxData to ensure it remains cleared or unchanged after error
  component.controlIdComboBoxData = [];

  // Act
  (component as any).LoadControlId();
  tick(); // flush observable/error

  // Assert
  expect(getSpy).toHaveBeenCalledWith((component as any).appConfigService.getAllControlIdurl);
  expect(displaySpy).toHaveBeenCalledWith(serverMessage);
  // After an error the combo data should remain empty (or not populated)
  expect(component.controlIdComboBoxData).toEqual([]);
  // Many components dispatch LOADINGACTION(false) on error â€” adapt if your code doesn't.
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));