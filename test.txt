
it('LoadControlId(): when API errors should call displayServiceErrors and keep controlIdComboBoxData empty (robust)', fakeAsync(() => {
  // Arrange - ensure appConfigService URL exists (test-local setup)
  (component as any).appConfigService = (component as any).appConfigService || {} as any;
  (component as any).appConfigService.getAllControlIdurl = '/api/controlIds';

  // Spy getRequest to throw an error observable
  const serverMessage = 'Server failure for control ids';
  const getSpy = spyOn(component.feeApiservice, 'getRequest').and.returnValue(
    throwError(() => ({ error: { statusMessage: serverMessage } }))
  );

  // Spy displayServiceErrors
  const displaySpy = spyOn(component as any, 'displayServiceErrors').and.callFake(() => {});

  // Make sure controlIdComboBoxData exists and is empty before call
  component.controlIdComboBoxData = [];

  // Spy store.dispatch if store exists on the component
  let dispatchSpy: jasmine.Spy | null = null;
  if (component['store']) {
    dispatchSpy = spyOn(component['store'], 'dispatch').and.callFake(() => {});
  }

  // Act
  (component as any).LoadControlId();
  tick(); // flush observable

  // Assert: feeApiservice called with the configured URL
  expect(getSpy).toHaveBeenCalledWith((component as any).appConfigService.getAllControlIdurl);

  // Assert: displayServiceErrors called with server message
  expect(displaySpy).toHaveBeenCalledWith(serverMessage);

  // Assert: combo data remains empty (not populated on error)
  expect(component.controlIdComboBoxData).toEqual([]);

  // Assert: if the component dispatched something, it should be a LOADINGACTION (flexible)
  if (dispatchSpy && dispatchSpy.calls.any()) {
    expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
  }
}));