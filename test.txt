import { of, throwError } from 'rxjs';
// ... other imports (LOADINGACTION if required)

it('onSaveClick(): error branch should set loading=false, dispatch(false), call displayServiceErrors, enable save button', () => {
  // make validations pass so code runs
  spyOn(component, 'ValidateFormControls').and.returnValue(false);
  spyOn(component, 'validateDates').and.returnValue(false);
  spyOn(component, 'validateFormData').and.returnValue(false);

  // minimal stubs for combo controls referenced in payload (value must not be null)
  component.cbCategory = { value: '1' } as any;
  component.cbCycle    = { value: '1' } as any;
  component.cbFormula  = { value: '1' } as any;
  component.cbAltDivision = { value: null } as any; // allowed to be null in code
  component.cbStatus   = { value: '1' } as any;
  component.cbOfficer  = { value: 'OFF1' } as any; // if code uses officer .value

  // minimal account object used in building payload (only fields used before error)
  component.account = {
    accountNbr: 'ACC123',
    acceptfee: '0',
    estacc: '0',
    actpp: '0',
    cashpp: '0',
    endpp: '0',
    feepp: '0',
    revshare: null,
    longacctnum: null,
    pcanumber: null,
    futureuse: null,
    ozId: null,
    disposition1: null,
    disposition2: null,
    disposition3: null
  } as any;

  // stub any utils used while preparing payload that might be called before the API call:
  // (if you already have a mock utils service just spy on the calls; otherwise provide simple stubs)
  spyOn(component['utils'], 'getFormattedDecimal').and.callFake((v: any) => v);
  spyOn(component['utils'], 'getValidString').and.callFake((v: any) => v ?? '');
  spyOn(component['utils'], 'getCurrentUser').and.returnValue('UT');
  spyOn(component['utils'], 'ToEstDate').and.returnValue('2025-01-01T00:00:00Z');
  spyOn(component['utils'], 'getDateAndDefaultTime').and.callFake((d:any)=> d ?? null);

  // spies for effects
  spyOn(component.store, 'dispatch').and.stub();
  spyOn(component, 'displayServiceErrors').and.stub();

  // make API throw so we hit error path
  const apiErr = { error: { statusMessage: 'Server error' } };
  spyOn(component['feeApiservice'], 'postRequest').and.returnValue(throwError(() => apiErr) as any);

  // call
  component.onSaveClick();

  // assertions: error branch should have run
  expect(component.loading).toBeFalse();
  expect(component.disableSavebtn).toBeFalse();
  expect(component.displayServiceErrors).toHaveBeenCalledWith('Server error');

  // there should be at least one dispatch; specifically a dispatch for LOADINGACTION(false)
  expect(component.store.dispatch).toHaveBeenCalled();
  // optionally verify LOADINGACTION(false) was dispatched (if LOADINGACTION is available in spec)
  // expect(component.store.dispatch).toHaveBeenCalledWith(new LOADINGACTION(false));
});