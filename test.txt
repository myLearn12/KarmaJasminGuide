import { fakeAsync, tick } from '@angular/core/testing';
import { of, throwError } from 'rxjs';

it('LoadDefaultComboBox(): complete -> sets combo data, deep-clones viewchild.options, clears loading and dispatches', fakeAsync(() => {
  // Arrange: data returned by forkJoin
  const divisions = [{ divisionId: 20, divisionDesc: 'Division A', divisionCd: 'D1' }];
  const controlIds = [{ conId: 5, controlDesc: 'Control A' }];
  const branchCds = [{ branchCode: 'B1', branchDesc: 'Branch One' }];

  // Spy getRequest to return the three observables in the same order used in LoadDefaultComboBox()
  spyOn(component.feeApiservice, 'getRequest').and.returnValues(
    of(divisions),   // divisions
    of(controlIds),  // controlIds
    of(branchCds)    // branchCds
  );

  // Prevent LoadTableRows or other side-effects if present
  if ((component as any).LoadTableRows) {
    spyOn(component as any, 'LoadTableRows');
  }

  // utils.LoadComboBoxData -> predictable mapped options
  const mappedDivisions = [{ label: 'Division A', value: '20' }];
  const mappedControls  = [{ label: 'Control A',  value: '5' }];
  const mappedBranches  = [{ label: 'Branch One',  value: 'B1' }];
  spyOn(component['utils'], 'LoadComboBoxData').and.callFake((arr: any[], label: string) => {
    if (label === 'divisionDesc') return mappedDivisions;
    if (label === 'controlDesc')  return mappedControls;
    if (label === 'branchDesc')   return mappedBranches;
    return [];
  });

  // Provide ViewChild mocks so assignments of .options succeed
  (component as any)._divisionComboBox   = { options: null };
  (component as any)._controlidComboBox  = { options: null };
  (component as any)._branchCdComboBox   = { options: null };

  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Act
  (component as any).LoadDefaultComboBox();
  tick(); // flush forkJoin subscribe next + complete

  // Assert: combo arrays built from utils.LoadComboBoxData
  expect(component.divisionComboBoxData).toEqual([{ options: mappedDivisions }]);
  expect(component.controlIdComboBoxData).toEqual([{ options: mappedControls }]);
  expect(component.branchCdComboBoxData).toEqual([{ options: mappedBranches }]);

  // Assert: ViewChild.options deep-cloned from the original arrays
  expect((component as any)._divisionComboBox.options).toEqual(JSON.parse(JSON.stringify(divisions)));
  expect((component as any)._controlidComboBox.options).toEqual(JSON.parse(JSON.stringify(controlIds)));
  expect((component as any)._branchCdComboBox.options).toEqual(JSON.parse(JSON.stringify(branchCds)));

  // loading false and store.dispatch called (LOADINGACTION false)
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));


it('LoadDefaultComboBox(): error branch -> displays service error and does NOT set combo data', fakeAsync(() => {
  // Arrange: make the first getRequest (divisions) throw a server error
  const errorResponse = { error: { statusMessage: 'Server failed' } };
  spyOn(component.feeApiservice, 'getRequest').and.returnValues(
    throwError(() => errorResponse), // divisions -> error
    of([]),                          // controlIds (unused)
    of([])                           // branchCds (unused)
  );

  const displaySpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Provide ViewChild mocks to avoid runtime errors (they should remain untouched on error)
  (component as any)._divisionComboBox   = { options: null };
  (component as any)._controlidComboBox  = { options: null };
  (component as any)._branchCdComboBox   = { options: null };

  // Act
  (component as any).LoadDefaultComboBox();
  tick();

  // Assert: displayServiceErrors called with the server message
  expect(displaySpy).toHaveBeenCalledWith('Server failed');

  // Combo data should remain undefined / empty (no complete run)
  expect(component.divisionComboBoxData).toBeUndefined();
  expect(component.controlIdComboBoxData).toBeUndefined();
  expect(component.branchCdComboBoxData).toBeUndefined();

  // loading should be false and dispatch should have been called to clear LOADING state
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalled();
}));
