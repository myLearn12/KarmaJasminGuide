it('processRecord: should POST all-account payload, load rows and show action modal on success', fakeAsync(() => {
  // Arrange
  (component as any).appConfigService = { restoreAccountUrl: '/mock-restore/' };
  component.region = { regionId: 99 } as any;
  component.selectedMonthEndDate = new Date('2025-08-01');
  component.currentDateTime = '10:00:00';
  // radio value empty string triggers "all" branch per code snippet
  (component as any).accountRadioButton = { value: '' };

  // stub utils used
  const utils = component['utils'] as any;
  spyOn(utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-08-01T10:00:00');
  spyOn(utils, 'getCurrentUser').and.returnValue('tester');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-01T10:00:00');

  // Mock response for postRequest and restoreAccounts returned by LoadTableRows
  const apiResponse = [{ recordCount: 5 }];
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of(apiResponse));

  // Spies for side-effects
  const loadSpy = spyOn(component as any, 'LoadTableRows').and.callFake((r) => {
    // simulate component.restoreAccounts being filled in LoadTableRows
    (component as any).restoreAccounts = apiResponse as any;
  });
  const actionModalSpy = spyOn((component as any)._actionModal || (component as any), 'show').and.callFake(() => {});
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callThrough();

  // initial states
  component.loading = true;
  component.disbleButtonAction = true;

  // Act
  (component as any).processRecord();
  tick();

  // Assert
  expect(postSpy).toHaveBeenCalled();
  const [calledUrl, calledPayload] = postSpy.calls.mostRecent().args as [string, any];
  expect(calledUrl).toContain('/mock-restore/');
  expect(Array.isArray(calledPayload)).toBeTrue();
  // UI/state assertions
  expect(loadSpy).toHaveBeenCalledWith(apiResponse);
  expect(component.totalRecordCount).toBe(5);
  expect(component.totalSuccessRecordCount).toBe(5);
  expect(component.totalErrorRecordCount).toBe(0);
  expect(component.isData).toBeFalse();
  expect(component.disbleButtonAction).toBeFalse();
  expect(component.loading).toBeFalse();
  expect(actionModalSpy).toHaveBeenCalled();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));


it('processRecord: should POST spec-account payload, compute totals and show action modal on success', fakeAsync(() => {
  // Arrange
  (component as any).appConfigService = { restoreAccountUrl: '/mock-restore/' };
  component.region = { regionId: 11 } as any;
  component.selectedMonthEndDate = new Date('2025-08-01');
  component.currentDateTime = '10:00:00';
  // radio non-empty triggers spec-account branch
  (component as any).accountRadioButton = { value: 'SOMEVAL' };

  // Provide some SpecAcct entries (only some defined)
  (component as any).SpecAcct1 = 'ACC1';
  (component as any).SpecAcct2 = null;
  (component as any).SpecAcct3 = 'ACC3';
  (component as any).SpecAcct4 = null;
  (component as any).SpecAcct5 = null;

  // stub utils
  const utils = component['utils'] as any;
  spyOn(utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-08-01T10:00:00');
  spyOn(utils, 'getCurrentUser').and.returnValue('tester');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-01T10:00:00');

  // Simulate restoreAccounts returned by service that include hasError flags
  const serviceResult = [
    { id: 1, hasError: true },
    { id: 2, hasError: false },
    { id: 3, hasError: false }
  ];
  // postRequest returns the response and LoadTableRows will set restoreAccounts
  spyOn(component.feeApiservice, 'postRequest').and.returnValue(of(serviceResult));
  const loadSpy = spyOn(component as any, 'LoadTableRows').and.callFake((r) => {
    (component as any).restoreAccounts = serviceResult as any;
  });
  const actionModalSpy = spyOn((component as any)._actionModal || (component as any), 'show').and.callFake(() => {});
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callThrough();

  component.loading = true;
  component.disbleButtonAction = true;

  // Act
  (component as any).processRecord();
  tick();

  // Assert
  expect(loadSpy).toHaveBeenCalledWith(serviceResult);
  expect(component.restoreAccounts.length).toBe(3);
  expect(component.totalRecordCount).toBe(3);
  expect(component.totalErrorRecordCount).toBe(1);
  expect(component.totalSuccessRecordCount).toBe(2);
  // isData true because totalErrorRecordCount !== 0
  expect(component.isData).toBeTrue();
  expect(actionModalSpy).toHaveBeenCalled();
  expect(component.disbleButtonAction).toBeFalse();
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));


it('processRecord: should handle API error by clearing, showing error and resetting state', fakeAsync(() => {
  // Arrange
  (component as any).appConfigService = { restoreAccountUrl: '/mock-restore/' };
  component.region = { regionId: 55 } as any;
  component.selectedMonthEndDate = new Date('2025-08-01');
  component.currentDateTime = '10:00:00';
  (component as any).accountRadioButton = { value: '' }; // try all-accounts path

  const utils = component['utils'] as any;
  spyOn(utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-08-01T10:00:00');
  spyOn(utils, 'getCurrentUser').and.returnValue('tester');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-01T10:00:00');

  // make postRequest throw
  const apiError = { error: { statusMessage: 'Server crashed' } };
  spyOn(component.feeApiservice, 'postRequest').and.returnValue(throwError(() => apiError));

  // spies for error path
  const clearSpy = spyOn(component as any, 'onClearButtonClick');
  const displaySpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callThrough();

  component.loading = true;
  component.disbleButtonAction = true;

  // Act
  (component as any).processRecord();
  tick();

  // Assert
  expect(clearSpy).toHaveBeenCalled();
  expect(displaySpy).toHaveBeenCalledWith('Server crashed');
  expect(component.loading).toBeFalse();
  expect(component.disbleButtonAction).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));