it('LoadDefaultComboBox(): complete -> sets combo data and deep-clones viewchild.options, clears loading and dispatches LOADINGACTION(false)', fakeAsync(() => {
  // Arrange: provide appConfigService URLs (component may read these privately)
  (component as any).appConfigService = {
    getAllRevShareTypeCdUrl: '/api/revsharetypes',
    getAllCostCenterUrl: '/api/costcenters'
  } as any;

  // Data returned by the two getRequest calls
  const revenueShares = [
    { revShareTypeId: 10, revShareTypeDesc: 'Revenue A', revShareTypeCd: 'R1' }
  ];
  const costCenters = [
    { costCenterNbr: '100', costCenterDesc: 'Cost A', costCenterId: 1 }
  ];

  // Capture called URLs (debugging if something mismatches)
  const calledUrls: string[] = [];

  // Stub feeApiservice.getRequest robustly (substring matching)
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url?: string) => {
    calledUrls.push(String(url));
    const u = String(url || '').toLowerCase();
    if (u.includes('revshare') || u.includes('revsharetype')) {
      return of(revenueShares);
    }
    if (u.includes('cost') || u.includes('costcenter')) {
      return of(costCenters);
    }
    // fallback to empty array to avoid crashes
    return of([]);
  });

  // Stub utils.LoadComboBoxData to return the predictable mapped options used in combo data
  const mappedRevenue = [{ label: 'Revenue A', value: '10' }];
  const mappedCostcenters = [{ label: 'Cost A', value: '100' }];
  spyOn(component['utils'], 'LoadComboBoxData').and.callFake((arr: any[], label: string, _code: string, id: string) => {
    if (label === 'revShareTypeDesc') return mappedRevenue;
    if (label === 'costCenterDesc') return mappedCostcenters;
    return [];
  });

  // Provide ViewChild placeholders so assignments to .options succeed
  (component as any)._revenueShareComboBox = { options: null };
  (component as any)._costCenterComboBox = { options: null };

  // Prevent side effects of LoadTableRows (not under test here)
  if ((component as any).LoadTableRows) {
    spyOn(component as any, 'LoadTableRows').and.callFake(() => {});
  }

  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Act: call the method and flush async work
  (component as any).LoadDefaultComboBox();
  tick(); // flush forkJoin and subscribe complete

  // Sanity check: if URL matching failed, show helpful failure
  const sawRev = calledUrls.some(u => /revshare|revsharetype/i.test(u));
  const sawCost = calledUrls.some(u => /cost|costcenter/i.test(u));
  if (!sawRev || !sawCost) {
    fail('LoadDefaultComboBox URL mismatch - calls made: ' + JSON.stringify(calledUrls, null, 2));
    return;
  }

  // Assert: combo data arrays use utils.LoadComboBoxData results
  expect(component.revenueShareComboBoxData).toEqual([{ options: mappedRevenue }]);
  expect(component.costCenterComboBoxData).toEqual([{ options: mappedCostcenters }]);

  // Assert: viewchild.options deep-cloned from original arrays
  expect((component as any)._revenueShareComboBox.options).toEqual(JSON.parse(JSON.stringify(revenueShares)));
  expect((component as any)._costCenterComboBox.options).toEqual(JSON.parse(JSON.stringify(costCenters)));

  // loading should be false and LOADINGACTION(false) dispatched at end (if your method dispatches)
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));