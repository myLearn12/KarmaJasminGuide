it('onAcceptButtonClick(ActionType.update) -> next(): should regenerate table and show success message', fakeAsync(() => {
  // Arrange: make validateFormControls allow the action
  spyOn((component as any), 'validateFormControls').and.returnValue(false);

  // Provide minimal UI combo mocks so payload building doesn't crash
  (component as any)._revenueShareComboBox = { value: '10' };
  (component as any)._costCenterComboBox  = { value: '100' };

  // Ensure a revShrGlAcctmap exists (used in payload and other code)
  component.revShrGlAcctmap = {
    revShareGlAcctId: 321,
    revShareDesc: 'SOME',
    glAccountNumber: 'GL-1',
    abaNbr: 'ABA1',
    costCenterNbr: '100'
  } as any;

  // Spy the two things we expect to be called in next()
  const genSpy = spyOn(component as any, 'GenerateTableRows').and.stub();
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue').and.stub();

  // Make putRequest emit next() (and complete - that's OK). of({}) triggers next then complete.
  const putSpy = spyOn(component.feeApiservice, 'putRequest').and.returnValue(of({}));

  // If complete() in your implementation calls getUpdatedModel or audit log,
  // stub them to avoid side effects in this small test:
  if ((component as any).getUpdatedModel) { spyOn(component as any, 'getUpdatedModel').and.returnValue({}); }
  const auditSvc = (component as any).auditLogService;
  if (auditSvc && auditSvc.writeAuditLog) { spyOn(auditSvc, 'writeAuditLog').and.stub(); }

  // Also stub validateFormControls (done) and any UI hide/clear functions to avoid extra side effects
  if ((component as any).clearSelection) { spyOn(component as any, 'clearSelection').and.stub(); }
  if ((component as any)._actionModal && (component as any)._actionModal.hide) { spyOn((component as any)._actionModal, 'hide').and.stub(); }

  // Act
  component.onAcceptButtonClick(ActionType.update);
  tick(); // flush observable

  // Assert
  expect(putSpy).toHaveBeenCalled();
  expect(genSpy).toHaveBeenCalled();
  expect(setMsgSpy).toHaveBeenCalledWith(BlockMessageType.success, component.updateSuccessMessage);
}));