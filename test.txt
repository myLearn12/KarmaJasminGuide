it('onAcceptButtonClick(ActionType.update): calls putRequest with update payload, regenerates table and writes audit log on complete', fakeAsync(() => {
  // Arrange: make validateFormControls allow action
  spyOn(component as any, 'validateFormControls').and.returnValue(false);

  // Provide appConfigService URL (appConfigService is private on the component)
  (component as any).appConfigService = {
    updateDivConBraMappingUrl: '/api/divconbra/update/'
  } as any;

  // Provide combo ViewChild mocks (values as strings like the real component expects)
  (component as any)._divisionComboBox = { value: '10' };
  (component as any)._controlIdComboBox = { value: '200' };
  (component as any)._branchCdComboBox = { value: 'B1' };

  // Provide the current (mutated) model and the selected snapshot used for restore/audit
  component.divConBraMap = {
    divConBraId: 99,
    activeIndic: true,
    // other properties may exist but aren't necessary for this test
  } as any;

  component.selectedDivConBraMap = JSON.parse(JSON.stringify(component.divConBraMap));

  // Provide lookup arrays so getUpdatedModel() / other helpers won't throw
  component.divisions = [{ divisionId: 10, divisionCd: 'D10', divisionDesc: 'Division 10' }] as any;
  component.controlIds = [{ conId: 200, controlDesc: 'Control 200' }] as any;
  component.branchCds = [{ branchCode: 'B1', branchDesc: 'Branch 1' }] as any;

  // Spies for side-effect methods
  const putSpy = spyOn(component.feeApiservice, 'putRequest').and.returnValue(of({})); // success
  const genSpy = spyOn(component as any, 'GenerateTableRows');
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue');
  // auditLogService is private; access via bracket notation
  const auditSpy = spyOn((component as any)['auditLogService'], 'writeAuditLog');

  // Act
  component.onAcceptButtonClick(ActionType.update);
  tick(); // flush asynchronous subscription (next + complete)

  // Assert: HTTP called with correct URL + payload containing the combo values
  expect(putSpy).toHaveBeenCalledTimes(1);
  const [calledUrl, calledPayload] = putSpy.calls.mostRecent().args as [string, any];
  expect(calledUrl).toBe('/api/divconbra/update/' + component.divConBraMap.divConBraId);

  // Payload contains expected fields (strings because .toString() used in code)
  expect(calledPayload).toEqual(jasmine.objectContaining({
    divisionId: '10',
    controlId: '200',
    branchCd: 'B1',
    activeIndic: true,
    updatedBy: jasmine.any(String),
    updatedDt: jasmine.any(String)
  }));

  // Next() side effects
  expect(genSpy).toHaveBeenCalled();
  expect(setMsgSpy).toHaveBeenCalledWith(BlockMessageType.success, component.updateSuccessMessage);

  // Complete() should call audit log with expected args (flexible matching)
  expect(auditSpy).toHaveBeenCalled();
  const auditArgs = auditSpy.calls.mostRecent().args;
  // first arg is the id key, second arg should be the id as string
  expect(auditArgs[0]).toBe('divConBraId');
  expect(auditArgs[1]).toBe(component.divConBraMap.divConBraId.toString());
  // third and fourth args are objects (selected snapshot and updated model)
  expect(auditArgs[2]).toEqual(component.selectedDivConBraMap);
  expect(auditArgs[3]).toEqual(jasmine.any(Object));
  // last args: action and title
  expect(auditArgs[4]).toBe((component as any)['auditLogService'].updateAction);
  expect(auditArgs[5]).toBe(component.PageTitle);
}));
