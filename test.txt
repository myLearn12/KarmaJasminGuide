// Paste these `it(...)` blocks into your existing spec (inside the existing describe/ beforeEach
// where `component`, `fixture`, `feeApiService`, `appConfigService`, `store` and modals are set up).
// They intentionally avoid a second describe/beforeEach and only contain focused test cases for processRecord().

it('processRecord(): success with one record -> stops loading, dispatches LOADINGACTION(false), sets totalRecordCount and shows action modal', (done) => {
  // arrange
  component.sheetName = 'Sheet1';
  component.worksheet = { Sheet1: [{ acctNbr: '111' }] };
  component.region = { regionId: 'R001' };
  spyOn(component.utils, 'getFormattedDateAndTimeEST').and.returnValue('2025-01-01T00:00:00Z');
  const showSpy = spyOn(component._actionModal, 'show').and.callFake(() => {});
  const postSpy = spyOn(feeApiService, 'postRequest').and.returnValue(of([{ restoreAccountId: 1 }]));

  // act
  component.processRecord();

  // assert (subscribe handlers run synchronously for `of`, but use setTimeout to be robust)
  setTimeout(() => {
    expect(postSpy).toHaveBeenCalled();
    expect(component.loading).toBeFalse();
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
    expect(component.totalRecordCount).toBe(1);
    expect(showSpy).toHaveBeenCalled();
    done();
  }, 0);
});

it('processRecord(): success with empty result -> stops loading, totalRecordCount 0, still triggers modal show', (done) => {
  component.sheetName = 'Sheet1';
  component.worksheet = { Sheet1: [{ acctNbr: 'A1' }] };
  component.region = { regionId: 'R001' };
  spyOn(feeApiService, 'postRequest').and.returnValue(of([]));
  const showSpy = spyOn(component._actionModal, 'show').and.callFake(() => {});

  component.processRecord();

  setTimeout(() => {
    expect(component.loading).toBeFalse();
    expect(component.totalRecordCount).toBe(0);
    expect(showSpy).toHaveBeenCalled(); // component shows modal even when response empty per code path
    done();
  }, 0);
});

it('processRecord(): server error -> calls displayServiceErrors, clears loading and dispatches LOADINGACTION(false)', (done) => {
  component.sheetName = 'Sheet1';
  component.worksheet = { Sheet1: [{ acctNbr: 'X1' }] };
  component.region = { regionId: 'R001' };
  const errorObj = { error: { statusMessage: 'Server failure' } };
  spyOn(feeApiService, 'postRequest').and.returnValue(throwError(errorObj));
  const dispSpy = spyOn(component, 'displayServiceErrors').and.callThrough();

  component.processRecord();

  setTimeout(() => {
    expect(dispSpy).toHaveBeenCalledWith('Server failure');
    expect(component.loading).toBeFalse();
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
    done();
  }, 0);
});

it('processRecord(): constructs bulk payload length equal to number of worksheet rows and posts correct payload', (done) => {
  component.sheetName = 'Sheet1';
  const rows = [{ acctNbr: '1' }, { acctNbr: '2' }, { acctNbr: '3' }];
  component.worksheet = { Sheet1: rows };
  component.region = { regionId: 'R002' };
  // capture the payload argument passed to postRequest
  const postSpy = spyOn(feeApiService, 'postRequest').and.callFake((url: any, payload: any) => {
    // assert inside spy that payload length equals rows length
    expect(Array.isArray(payload)).toBeTrue();
    expect(payload.length).toBe(rows.length);
    return of([{ ok: true }]);
  });

  component.processRecord();

  setTimeout(() => {
    expect(postSpy).toHaveBeenCalled();
    done();
  }, 0);
});

it('processRecord(): when API returns restoreAccounts with errors -> sets totalErrorRecordCount and shows modal (isData true)', (done) => {
  component.sheetName = 'Sheet1';
  component.worksheet = { Sheet1: [{ acctNbr: '1' }, { acctNbr: '2' }] };
  component.region = { regionId: 'R010' };
  // simulate API returning a list with some items having hasError true/false
  const restoreResponse = [
    { acctNum: '1', hasError: true },
    { acctNum: '2', hasError: false }
  ];
  spyOn(feeApiService, 'postRequest').and.returnValue(of(restoreResponse));
  const showSpy = spyOn(component._actionModal, 'show').and.callFake(() => {});

  component.processRecord();

  setTimeout(() => {
    expect(component.loading).toBeFalse();
    expect(component.totalRecordCount).toBe(restoreResponse.length);
    expect(component.totalErrorRecordCount).toBe(restoreResponse.filter(x => x.hasError === true).length);
    expect(component.totalSuccessRecordCount).toBe(restoreResponse.filter(x => x.hasError === false).length);
    expect(component.isData).toBeTrue();
    expect(showSpy).toHaveBeenCalled();
    done();
  }, 0);
});

it('processRecord(): no worksheet rows -> should not call API, should clear loading and dispatch LOADINGACTION(false)', (done) => {
  component.sheetName = 'Sheet1';
  component.worksheet = { Sheet1: [] }; // empty
  const postSpy = spyOn(feeApiService, 'postRequest').and.returnValue(of([]));
  // call
  component.processRecord();
  setTimeout(() => {
    // no rows -> payload will be [] and component still uses postRequest in some implementations;
    // defensively assert that if api is called it is with an array length 0 OR not called depending on your implementation.
    // Here we assert that loading was cleared and dispatch called.
    expect(component.loading).toBeFalse();
    expect(store.dispatch).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
    // postSpy may or may not be called depending on implementation; if your implementation avoids calling when no rows,
    // change the expectation accordingly. We'll allow either: ensure test doesn't fail if called.
    done();
  }, 0);
});