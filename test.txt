import { fakeAsync, tick } from '@angular/core/testing';
import { of } from 'rxjs';

it('onAcceptButtonClick(ActionType.add) -> posts payload, regenerates table, shows success and writes audit log (self-contained)', fakeAsync(() => {
  // allow method to proceed
  spyOn(component as any, 'validateFormControls').and.returnValue(false);

  // Provide combo ViewChilds (they must exist and have .value)
  (component as any)._divisionComboBox = { value: '10' };
  (component as any)._controlIdComboBox = { value: '200' };
  (component as any)._branchCdComboBox = { value: 'BR1' };
  (component as any)._actionModal = { hide: () => {}, show: () => {} };

  // Provide arrays used by getUpdatedModel() and other .find() calls
  component.divisions = [
    { divisionId: 10, divisionCd: 'D10', divisionDesc: 'Division 10' },
    { divisionId: 20, divisionCd: 'D20', divisionDesc: 'Division 20' }
  ] as any;

  component.controlIds = [
    { conId: 200, controlDesc: 'Control 200' }
  ] as any;

  component.branchCds = [
    { branchCode: 'BR1', branchDesc: 'Branch 1' }
  ] as any;

  // Minimal model used by Add path
  component.divConBraMap = {
    divConBraId: null,
    activeIndic: true,
    /* fields used by getUpdatedModel and audit log */
    createdBy: 'init',
    createdDt: '2025-01-01T00:00:00',
    updtById: null,
    updtDt: null
  } as any;

  // utils used by the component
  (component as any).utils = {
    ToEstDate: () => '2025-08-25T00:00:00',
    getCurrentUser: () => 'tester',
    getDisplayDate: (d: any) => d ? d : '',
    getFormatedString: (s: any) => (s == null ? '' : String(s)),
    isStringValid: (v: any) => v !== null && v !== undefined && String(v).trim() !== ''
  };

  // Prevent GenerateTableRows side-effects; spy on helpers
  const genSpy = spyOn(component as any, 'GenerateTableRows').and.callFake(() => {});
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue').and.callFake(() => {});
  spyOn(component['store'], 'dispatch').and.callFake(() => {}); // LOADINGACTION calls

  // stub feeApiservice.postRequest -> success (next + complete)
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of({}));

  // auditLogService is private in component; inject a spyable object
  (component as any).auditLogService = { writeAuditLog: (...args: any[]) => {} };
  const auditSpy = spyOn(component['auditLogService'], 'writeAuditLog').and.callFake(() => {});

  // Act
  component.onAcceptButtonClick(ActionType.add);
  tick(); // flush async (observables subscribe/complete)

  // Assert
  expect(postSpy).toHaveBeenCalled();
  expect(genSpy).toHaveBeenCalled();
  expect(setMsgSpy).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything());
  expect(auditSpy).toHaveBeenCalledWith(
    'NA',
    'NA',
    jasmine.any(Object), // unmodified model
    jasmine.any(Object), // getUpdatedModel result
    jasmine.anything(),  // action constant
    jasmine.any(String)  // page title
  );
}));
