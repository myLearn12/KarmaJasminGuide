it('processRecord (if-branch success): posts all-account payload, LoadTableRows called, totals & modal shown', fakeAsync(() => {
  // Arrange: pick the IF branch (all accounts) by setting accountRadioButton.value to ''
  (component as any).accountRadioButton = { value: '' };
  component.region = { regionId: 100 } as any;
  component.selectedMonthEndDate = new Date('2025-08-01');
  component.currentDateTime = '09:00:00';
  (component as any).appConfigService = { restoreAccountUrl: '/mock/restore/' };

  // Stub utils used before HTTP
  const utils = component['utils'] as any;
  spyOn(utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-08-01T09:00:00');
  spyOn(utils, 'getCurrentUser').and.returnValue('tester');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-01T09:00:00');

  // Simulated API response consumed by LoadTableRows
  const serviceResponse = [{ recordCount: 4 }];
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of(serviceResponse));

  // Simulate LoadTableRows populating restoreAccounts
  const loadSpy = spyOn(component as any, 'LoadTableRows').and.callFake((r) => {
    (component as any).restoreAccounts = r;
  });

  // Modal and dispatch spies
  const actionModalShowSpy = spyOn((component as any)._actionModal || (component as any), 'show').and.callFake(() => {});
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callThrough();

  // initial flags
  component.loading = true;
  component.disbleButtonAction = true;

  // Act
  (component as any).processRecord();
  tick();

  // Assert: post called, LoadTableRows used, totals set, modal shown, state reset
  expect(postSpy).toHaveBeenCalled();
  expect(loadSpy).toHaveBeenCalledWith(serviceResponse);

  expect(component.restoreAccounts.length).toBe(1);
  expect(component.totalRecordCount).toBe(4);
  expect(component.totalSuccessRecordCount).toBe(4);
  expect(component.totalErrorRecordCount).toBe(0);

  expect(component.isData).toBeFalse();
  expect(component.disbleButtonAction).toBeFalse();
  expect(component.loading).toBeFalse();
  expect(actionModalShowSpy).toHaveBeenCalled();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));


it('processRecord (if-branch error): outer postRequest throws -> subscription error handler runs and resets state', fakeAsync(() => {
  // Arrange: choose IF branch
  (component as any).accountRadioButton = { value: '' };
  component.region = { regionId: 200 } as any;
  component.selectedMonthEndDate = new Date('2025-08-01');
  component.currentDateTime = '09:00:00';
  (component as any).appConfigService = { restoreAccountUrl: '/mock/restore/' };

  // Stub utils
  const utils = component['utils'] as any;
  spyOn(utils, 'getFormatedDateAndTimeEST').and.returnValue('2025-08-01T09:00:00');
  spyOn(utils, 'getCurrentUser').and.returnValue('tester');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-01T09:00:00');

  // Make postRequest throw so subscribe.error executes
  const serverError = { error: { statusMessage: 'All-accounts failed' } };
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(
    throwError(() => serverError)
  );

  // Spies for error branch side-effects
  const clearSpy = spyOn(component as any, 'onClearButtonClick');
  const displaySpy = spyOn(component as any, 'displayServiceErrors');
  const dispatchSpy = spyOn(component['store'], 'dispatch').and.callThrough();

  // initial flags
  component.loading = true;
  component.disbleButtonAction = true;

  // Act
  (component as any).processRecord();
  tick(); // flush

  // Assert: error-path was executed and states reset
  expect(postSpy).toHaveBeenCalled();
  expect(clearSpy).toHaveBeenCalled();
  expect(displaySpy).toHaveBeenCalledWith('All-accounts failed');
  expect(component.loading).toBeFalse();
  expect(component.disbleButtonAction).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));