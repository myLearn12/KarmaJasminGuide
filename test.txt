it('getUpdatedModel() — when tax account: builds model with division fields', () => {
  // arrange
  component.catGlmap = {
    categoryGlId: 123,
    glAcctNbr: 'GL-999',
    createdBy: 'cby',
    createdDt: '2025-08-01T00:00:00',
    updatedBy: 'uby',
    updatedDt: '2025-08-02T00:00:00'
  } as any;

  // combo/viewchild mocks
  (component as any)._categoryComboBox = { value: ['7'] };
  (component as any).categoryComboBox = { value: ['7'] }; // method uses categoryComboBox too
  (component as any).divisionComboBox = { value: ['20'] };

  // lists used by the method (must be arrays so .find works)
  component.categories = [
    { categoryId: 7, categoryDescription: 'Estate', categoryCode: '4' }
  ] as any[];

  component.divisions = [
    { divisionId: 20, divisionDesc: 'Division A', divisionCd: 'D1' }
  ] as any[];

  // ensure isTaxAccount() returns true
  spyOn(component as any, 'isTaxAccount').and.returnValue(true);

  // act
  const updated = (component as any).getUpdatedModel();

  // assert
  expect(updated).toBeDefined();
  expect(updated.categoryGlId).toBe(123);
  expect(updated.glAcctNbr).toBe('GL-999');
  expect(updated.categoryId).toBe(7); // parseInt('7')
  expect(updated.categoryCode).toBe('4'); // from categories.find(...)
  expect(updated.catgoryDesc).toBe('Estate');
  expect(updated.divisionId).toBe(20);
  expect(updated.divisionCode).toBe('D1');
  expect(updated.divisionDesc).toBe('Division A');
  expect(updated.createdBy).toBe('cby');
  expect(updated.createdDt).toBe('2025-08-01T00:00:00');
  expect(updated.updatedBy).toBe('uby');
  expect(updated.updatedDt).toBe('2025-08-02T00:00:00');
});

it('getUpdatedModel() — when NOT tax account: division fields left unchanged', () => {
  // arrange
  component.catGlmap = {
    categoryGlId: 999,
    glAcctNbr: 'GL-1000',
    createdBy: 'cby2',
    createdDt: '2025-01-01T00:00:00',
    updatedBy: 'uby2',
    updatedDt: '2025-02-02T00:00:00'
  } as any;

  (component as any)._categoryComboBox = { value: ['8'] };
  (component as any).categoryComboBox = { value: ['8'] };

  // keep divisionComboBox defined so .toString() doesn't blow up; values shouldn't be used
  (component as any).divisionComboBox = { value: ['555'] };

  component.categories = [
    { categoryId: 8, categoryDescription: 'Other', categoryCode: '7' }
  ] as any[];

  component.divisions = [
    { divisionId: 20, divisionDesc: 'Division A', divisionCd: 'D1' }
  ] as any[];

  spyOn(component as any, 'isTaxAccount').and.returnValue(false);

  // act
  const updated = (component as any).getUpdatedModel();

  // assert basic mapped fields
  expect(updated).toBeDefined();
  expect(updated.categoryGlId).toBe(999);
  expect(updated.glAcctNbr).toBe('GL-1000');
  expect(updated.categoryId).toBe(8);
  expect(updated.categoryCode).toBe('7');
  expect(updated.catgoryDesc).toBe('Other');

  // when not tax-account the method should not override division fields;
  // the code sets them to `updatedModel.divisionId` (which was initialized on the instance)
  // so assert they are undefined / unchanged (depending on your class defaults).
  // Use truthy/falsy checks — adjust to your CategoryGLAcctMapping default values if needed.
  expect(updated.divisionId).toBeUndefined();
  expect(updated.divisionCode).toBeUndefined();
  expect(updated.divisionDesc).toBeUndefined();

  expect(updated.createdBy).toBe('cby2');
  expect(updated.createdDt).toBe('2025-01-01T00:00:00');
  expect(updated.updatedBy).toBe('uby2');
  expect(updated.updatedDt).toBe('2025-02-02T00:00:00');
});