it('onAcceptButtonClick(ActionType.add): posts payload, regenerates table, shows success and writes audit log (self-contained)', fakeAsync(() => {
  // ---------- Arrange ----------
  // Provide the combo viewchild values used by the code
  (component as any)._divisionComboBox = { value: '20' };
  (component as any)._costCenterComboBox = { value: '100' };

  // Provide arrays that .find/.filter will operate on
  component.divisions = [
    { divisionId: 20, divisionDesc: 'Division A', divisionCd: 'D1', costCenterId: 1 }
  ] as any;
  component.costCenters = [
    { costCenterId: 1, costCenterNbr: '100', costCenterDesc: 'Cost A' }
  ] as any;
  component.revenueShares = [
    { revShareTypeId: 10, revShareTypeDesc: 'Revenue A', revShareTypeCd: 'R1' }
  ] as any;

  // The model being added
  component.altdivabacostcntrmap = {
    altDivIdCostCntrMapId: 99,
    altDivId: 20,
    abaNbr: 'ABA-1',
    costCenterNbr: '100',
    startDt: null,
    endDt: null
  } as any;

  // Ensure validateFormControls allows execution
  spyOn(component as any, 'validateFormControls').and.returnValue(false);

  // Stub POST to succeed (so complete() runs)
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of({}));

  // Spy on helpers called inside complete()
  const genSpy = spyOn(component as any, 'GenerateTableRows').and.callFake(() => {});
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue').and.callFake(() => {});

  // Provide auditLogService and spy on writeAuditLog
  (component as any).auditLogService = {
    writeAuditLog: (_a?: any, _b?: any, _c?: any, _d?: any, _e?: any, _f?: any) => {}
  };
  const auditSpy = spyOn((component as any).auditLogService, 'writeAuditLog').and.callThrough();

  // Make getUpdatedModel predictable (complete() uses it to pass to auditLogService)
  spyOn(component as any, 'getUpdatedModel').and.returnValue({ updated: true });

  // Provide clearSelection and _actionModal so final cleanup doesn't throw
  const clearSpy = spyOn(component as any, 'clearSelection').and.callFake(() => {});
  (component as any)._actionModal = { hide: () => {} };
  const modalHideSpy = spyOn((component as any)._actionModal, 'hide').and.callThrough();

  // ---------- Act ----------
  component.onAcceptButtonClick(ActionType.add);
  tick(); // let the observable complete run

  // ---------- Assert ----------
  expect(postSpy).toHaveBeenCalled();               // posted payload
  expect(genSpy).toHaveBeenCalled();                // regenerated table rows
  expect(setMsgSpy).toHaveBeenCalledWith(jasmine.anything(), (component as any).addSuccessMessage);
  expect(auditSpy).toHaveBeenCalled();              // audit log written

  // check audit args loosely (flexible so test won't be brittle)
  const args = auditSpy.calls.mostRecent().args;
  expect(args[0]).toBe('NA');                       // add uses 'NA'
  expect(args[1]).toBe('NA');
  expect(typeof args[2]).toBe('object');            // unmodified object passed
  expect(typeof args[3]).toBe('object');            // getUpdatedModel() result
  expect(args[5]).toBeDefined();                    // page title passed

  // cleanup called
  expect(clearSpy).toHaveBeenCalled();
  expect(modalHideSpy).toHaveBeenCalled();
}));
