it('ngOnInit complete: sets divisionComboBoxData, deep-clones viewchild.options, clears loading and dispatches LOADINGACTION(false) (exact URL matching)', fakeAsync(() => {
  // Arrange
  spyOn(component['authService'], 'canHideFinanceAdminControls').and.returnValue(false);

  // Realistic API-returned raw model objects (RevShareTypeCd & Division)
  const revenueShares = [
    {
      selected: false,
      revShareTypeId: 10,
      revShareTypeCd: 'R1',
      revShareTypeDesc: 'Revenue A',
      activeIndic: true,
      createdBy: 'u',
      createdDt: '2025-01-01',
      updatedBy: 'u',
      updatedDt: '2025-01-02'
    }
  ];

  const divisions = [
    {
      selected: false,
      divisionId: 20,
      divisionCd: 'D1',
      divisionDesc: 'Division A',
      regDesc: '',
      revShareDivId: 0,
      revShareTypeId: 10,
      revShareTypeCd: 'R1',
      revShareDesc: '',
      divisionShortNm: 'DivA',
      costCenterId: 0,
      costCenterNbr: 0,
      costCenterDesc: '',
      abaNbr: '',
      typeCd: '',
      activeIndic: true,
      createdBy: 'u',
      createdDt: '2025-01-01',
      updatedBy: 'u',
      updatedDt: '2025-01-02'
    }
  ];

  // other forkJoin returns (not asserted)
  const costcenters = [{ id: 1 }];
  const revShareDivMaps: any[] = [];

  // Stub getRequest to exactly match appConfigService URLs used in the component
  const cfg = component.appConfigService as any;
  const called: string[] = [];
  spyOn(component.feeApiservice, 'getRequest').and.callFake((url: string) => {
    called.push(String(url));
    // exact match using the config properties
    try {
      if (url === cfg.getAllCostCenterUrl) { return of(costcenters); }
      if (url === cfg.getAllRevShareDivMappingUrl) { return of(revShareDivMaps); }
      if (url === cfg.getAllRevShareTypeCdUrl) { return of(revenueShares); }
      if (url === cfg.getAllDivisionUrl) { return of(divisions); }
    } catch (e) {
      // if cfg isn't shaped how we expect, fall through to safe defaults
    }
    // Fallback: return an identifiable object so we can debug if mismatch occurs
    return of([{ _unexpectedUrl: url }]);
  });

  // Ensure LoadComboBoxData returns label/value arrays
  const mappedRevenue = [{ label: 'Revenue A', value: '10' }]; // value is stringified id
  const mappedDivisions = [{ label: 'Division A', value: '20' }];
  spyOn(component['utils'], 'LoadComboBoxData').and.callFake((arr: any[], label: string, _code: string, id: string) => {
    if (label === 'revShareTypeDesc') return mappedRevenue;
    if (label === 'divisionDesc') return mappedDivisions;
    return [];
  });

  // Provide ViewChild mocks so .options assignment doesn't crash
  (component as any)._revenueShareComboBox = { options: null };
  (component as any)._divisionComboBox = { options: null };

  const dispatchSpy = spyOn(component['store'], 'dispatch');

  // Act
  component.ngOnInit();
  tick();

  // If test didn't match the expected URLs, print them for debugging
  const sawRev = called.includes(cfg.getAllRevShareTypeCdUrl);
  const sawDiv = called.includes(cfg.getAllDivisionUrl);
  if (!sawRev || !sawDiv) {
    fail('URL mismatch in test. Called urls: ' + JSON.stringify(called, null, 2) +
      '\nExpected to see: ' + cfg.getAllRevShareTypeCdUrl + ' and ' + cfg.getAllDivisionUrl);
    return;
  }

  // Assert: combo data arrays built using utils.LoadComboBoxData (label/value)
  expect(component.revenueShareComboBoxData).toEqual([{ options: mappedRevenue }]);
  expect(component.divisionComboBoxData).toEqual([{ options: mappedDivisions }]);

  // Assert: ViewChild.options deep-cloned from API arrays (raw objects)
  expect((component as any)._revenueShareComboBox.options).toEqual(JSON.parse(JSON.stringify(revenueShares)));
  expect((component as any)._divisionComboBox.options).toEqual(JSON.parse(JSON.stringify(divisions)));

  // loading turned off and LOADINGACTION(false) dispatched
  expect(component.loading).toBeFalse();
  expect(dispatchSpy).toHaveBeenCalledWith(jasmine.any(LOADINGACTION));
}));