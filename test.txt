it('onAcceptButtonClick(ActionType.add) -> posts payload, regenerates table, shows success and writes audit log (self-contained)', fakeAsync(() => {
  // Arrange - let validate pass
  spyOn(component as any, 'validateFormControls').and.returnValue(false);

  // Provide combo ViewChilds (they must exist and have .value)
  (component as any)._divisionComboBox = { value: '10' };
  (component as any)._controlIdComboBox = { value: '200' };
  (component as any)._branchCdComboBox = { value: 'BR1' };
  (component as any)._actionModal = { hide: () => {}, show: () => {} };

  // Provide arrays used by getUpdatedModel() and other .find() calls
  component.divisions = [
    { divisionId: 10, divisionCd: 'D10', divisionDesc: 'Division 10' },
    { divisionId: 20, divisionCd: 'D20', divisionDesc: 'Division 20' }
  ] as any;

  component.controlIds = [
    { conId: 200, controlDesc: 'Control 200' }
  ] as any;

  component.branchCds = [
    { branchCode: 'BR1', branchDesc: 'Branch 1' }
  ] as any;

  // Minimal model used by Add path
  component.divConBraMap = {
    divConBraId: null,
    activeIndic: true,
    createdBy: 'init',
    createdDt: '2025-01-01T00:00:00',
    updtById: null,
    updtDt: null
  } as any;

  // utils used by component (small subset)
  (component as any).utils = {
    ToEstDate: () => '2025-08-25T00:00:00',
    getCurrentUser: () => 'tester',
    getDisplayDate: (d: any) => d ? d : '',
    getFormatedString: (s: any) => (s == null ? '' : String(s)),
    isStringValid: (v: any) => v !== null && v !== undefined && String(v).trim() !== ''
  };

  // Prevent GenerateTableRows side-effects; spy helpers
  const genSpy = spyOn(component as any, 'GenerateTableRows').and.callFake(() => {});
  const setMsgSpy = spyOn(component as any, 'SetMessageTypeAndValue').and.callFake(() => {});
  spyOn(component['store'], 'dispatch').and.callFake(() => {}); // LOADINGACTION calls

  // stub feeApiservice.postRequest -> success
  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of({}));

  // auditLogService may be private — set a test double and spy
  (component as any).auditLogService = { writeAuditLog: (_a: any, _b: any, _c: any, _d: any, _e: any, _f: any) => {} };
  const auditSpy = spyOn(component['auditLogService'], 'writeAuditLog').and.callFake(() => {});

  // Act
  component.onAcceptButtonClick(ActionType.add);
  tick(); // flush subscribe/complete

  // Assert basics
  expect(postSpy).toHaveBeenCalled();
  expect(genSpy).toHaveBeenCalled();
  expect(setMsgSpy).toHaveBeenCalled();

  // Audit log called — be flexible about exact objects
  expect(auditSpy).toHaveBeenCalled();
  const args = auditSpy.calls.mostRecent().args;
  // arg[0] and arg[1] should be 'NA' per the component
  expect(args[0]).toBe('NA');
  expect(args[1]).toBe('NA');

  // arg[2] is the unmodified model passed (should be an object with some keys)
  expect(args[2]).toEqual(jasmine.any(Object));
  // it should at least contain the createdBy/createdDt or activeIndic keys
  expect(args[2]).toEqual(jasmine.objectContaining({
    // some keys may be blank initially — we check presence rather than exact value
    createdBy: jasmine.anything()
  }));

  // arg[3] is the updated model returned by getUpdatedModel()
  expect(args[3]).toEqual(jasmine.any(Object));

  // arg[5] should be a string title (page title)
  expect(typeof args[5]).toBe('string');
  expect(args[5]).toContain('Mapping'); // optional check that page title contains sensible word
}));
