it('logAccountAudit (edit): builds audit trail when old and new account values differ (covers many branches safely)', fakeAsync(() => {
  // Arrange
  component.isCloneAccount = false;

  // Old vs New — change a bunch of fields to trigger audit building
  component.oldAccountValues = {
    longacctnum: 'OLD-LONG',
    accountNm: 'OLD-NAME',
    dateopen: '2025-08-01',
    dateclosed: '',
    estacc: 10,
    revshare: '0.20',
    futureuse: 'OLD-FUT',
    regionDescription: 'East',
    disposition3: 'OLD-DISP3',
    ofcrNm: 'OLD OFFICER',
    officer: '0001',
    ozId: 'OLDOZ',
    pcanumber: 'OLDPCA',
    estpp: 1, actpp: 2, endpp: 3, feepp: 4, cashpp: 5,
    accepfee: 6
  } as any;

  component.account = {
    accountNbr: 'ACC-99',
    longacctnum: 'NEW-LONG',
    accountNm: 'NEW-NAME',
    dateopen: '2025-08-02',
    dateclosed: '2025-08-03',
    estacc: 11,
    revshare: '0.50',
    futureuse: 'NEW-FUT',
    regionDescription: 'West',
    disposition3: 'NEW-DISP3',
    ofcrNm: 'NEW OFFICER',
    officer: '0002',
    ozId: 'NEWOZ',
    pcanumber: 'NEWPCA',
    estpp: 10, actpp: 20, endpp: 30, feepp: 40, cashpp: 50,
    accepfee: 60
  } as any;

  // Current combos (strings or arrays ok – method calls .toString())
  (component as any).cbStatus      = { value: ['A'] };
  (component as any).cbDivision    = { value: ['20'] };
  (component as any).cbAltDivision = { value: ['30'] }; // non-null to exercise that block
  (component as any).cbCycle       = { value: ['5'] };
  (component as any).cbFormula     = { value: ['11'] };
  (component as any).cbCategory    = { value: ['4ID'] }; // choose the category whose code is '4'

  // Old combo snapshots – MUST be initialized so .toString() is safe
  component.oldcbStatusValue      = ['B'];
  component.oldcbDivisionValue    = ['21'];
  component.oldcbAltDivisionValue = ['31'];
  component.oldcbCycleValue       = ['6'];
  component.oldcbFormulaValue     = ['12'];
  component.oldcbCategoryValue    = ['7ID'];

  // lookups used for region id and LoadComboBoxData labels
  component.regions = [
    { regionId: 1, regionDescription: 'West' },
    { regionId: 2, regionDescription: 'East' },
  ] as any;

  component.divisions = [
    { divisionId: 20, divisionDesc: 'Div A', divisionCd: 'DA' },
    { divisionId: 21, divisionDesc: 'Div B', divisionCd: 'DB' },
    { divisionId: 30, divisionDesc: 'Alt A', divisionCd: 'AA' },
    { divisionId: 31, divisionDesc: 'Alt B', divisionCd: 'AB' },
  ] as any;

  component.cycles = [
    { cycleId: 5, cycleDesc: 'Cycle 5' },
    { cycleId: 6, cycleDesc: 'Cycle 6' },
  ] as any;

  component.formulas = [
    { formulaId: 11, formulaDesc: 'Formula 11', formulaCd: 'F11' },
    { formulaId: 12, formulaDesc: 'Formula 12', formulaCd: 'F12' },
  ] as any;

  // include both: the selected cat (code '4') and a different previous cat (code '7')
  component.categories = [
    { categoryId: '4ID', categoryDescription: 'Estate', categoryCode: '4' },
    { categoryId: '7ID', categoryDescription: 'Other',  categoryCode: '7' },
  ] as any;

  // stubs
  spyOn(component.acctService, 'getAccountStatusDesc')
    .and.callFake((v: string) => v === 'A' ? 'Active' : 'Other');

  const utils = component['utils'] as any;
  spyOn(utils, 'getValidString')
    .and.callFake((x: any) => (x === '' || x === null || x === undefined) ? null : String(x));
  spyOn(utils, 'getFormatedDecimal')
    .and.callFake((n: any) => Number(n).toFixed(2));
  spyOn(utils, 'getDateAndDefaultTime')
    .and.callFake((d: any) => (d ? d : null));
  // Return label/value pairs that MATCH .toString() of ids above
  spyOn(utils, 'LoadComboBoxData')
    .and.callFake((arr: any[], label: string, _code: string, id: string) =>
      arr.map((r: any) => ({ label: r[label], value: String(r[id]) }))
    );
  spyOn(utils, 'getCurrentUser').and.returnValue('u1');
  spyOn(utils, 'ToEstDate').and.returnValue('2025-08-25T00:00:00');

  const postSpy = spyOn(component.feeApiservice, 'postRequest').and.returnValue(of({}));
  const showEditSpy = spyOn(component as any, 'showEditSuccess');

  // Act
  (component as any).logAccountAudit();
  tick();

  // Assert — POST happened
  expect(postSpy).toHaveBeenCalled();

  // Get the body SAFELY and assert shape without indexing [0] blindly
  const [, body] = postSpy.calls.mostRecent().args as [string, any];
  expect(body).toBeDefined();
  expect((body as any).acctAuditType).toBe('UPDATE');
  expect((body as any).acctNbr).toBe('ACC-99');

  // Parse audit data carefully
  const auditJson = (body as any).acctAuditData;
  expect(auditJson).toBeDefined();              // avoid "Expected undefined to be defined"
  const auditArr = JSON.parse(auditJson);
  expect(Array.isArray(auditArr)).toBeTrue();
  expect(auditArr.length).toBeGreaterThan(0);   // avoid reading [0] when empty

  // spot-check the combined text contains a few changed labels
  const merged = JSON.stringify(auditArr);
  expect(merged).toContain('Long Account Number'); // longacctnum diff
  expect(merged).toContain('Region');              // regionDescription diff
  expect(merged).toContain('Account Status');      // status diff (old B → new A)
  expect(merged).toContain('Division Cd Desc');    // division diff
  expect(merged).toContain('Cycle Id Desc');       // cycle diff
  expect(merged).toContain('Formula Cd Desc');     // formula diff
  expect(merged).toContain('Category Cd Desc');    // category diff

  // Complete handler should call showEditSuccess
  expect(showEditSpy).toHaveBeenCalled();
}));
